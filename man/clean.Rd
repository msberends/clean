% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/clean.R
\name{clean}
\alias{clean}
\alias{clean.data.frame}
\alias{clean_logical}
\alias{clean_factor}
\alias{clean_Date}
\alias{clean_numeric}
\alias{clean_character}
\title{Clean column data to a class}
\usage{
clean(x)

\method{clean}{data.frame}(x)

clean_logical(x, true = "^(Y.*|J.*|T|TRUE)$",
  false = "^(N.*|F|FALSE)$", na = NULL, fixed = FALSE)

clean_factor(x, levels = unique(x), ordered = FALSE,
  droplevels = FALSE, fixed = FALSE)

clean_Date(x, format = NULL, fixed = FALSE, ...)

clean_numeric(x, keep = "[0-9.,]", fixed = FALSE)

clean_character(x, keep = "[a-z]", fixed = FALSE)
}
\arguments{
\item{x}{data to clean}

\item{true}{\link[base]{regex} to interpret values as \code{TRUE}, see Details}

\item{false}{\link[base]{regex} to interpret values as \code{FALSE}, see Details}

\item{na}{\link[base]{regex} to force interpret values as \code{NA}, i.e. not as \code{TRUE} or \code{FALSE}}

\item{fixed}{logical to indicate whether regular expressions should be turned off}

\item{levels}{new factor levels, may be named with regular expressions to match existing values, see Details}

\item{ordered}{logical to indicate whether the factor levels must be ordered}

\item{droplevels}{logical to indicate whether non-existing factor levels should be dropped}

\item{format}{a date format that will be passed on to \code{\link{format_datetime}}, see Details}

\item{...}{other parameters passed on to \code{\link{as.Date}}}

\item{keep}{\link[base]{regex} to define the character that must be kept, see Details}
}
\description{
Use any of these functions to quickly clean columns in your data set. Use \code{clean()} to pick the functions that return the least relative number of \code{NA}s.
}
\details{
Using \code{clean()} on a vector will guess a cleaning function based on the potential number of \code{NAs} it returns. Using \code{clean()} on a data.frame to apply this guessed cleaning over all columns.

Info about the different functions:

\itemize{
  \item{\code{clean_logical}:\cr}{Use parameters \code{true} and \code{false} to match values using case-insensitive regular expressions (\link[base]{regex}). Unmatched values are considered \code{NA}. At default, values starting with a Y or J are considered \code{TRUE} and values starting with an N are considered \code{FALSE}. Use parameter \code{na} to override values as \code{NA} that would else be matched with \code{true} or \code{false}. See Examples.}
  \item{\code{clean_factor}:\cr}{Use parameter \code{levels} to set new factor levels. They can be case-insensitive regular expressions to match existing values of \code{x}. For matching, new values for \code{levels} are internally temporary sorted descending on text length. See Examples.}
  \item{\code{clean_Date}:\cr}{Use parameter \code{format} to define a date format, or leave it empty to have the format guessed. Use \code{"Excel"} to read values as Microsoft Excel dates. The \code{format} parameter will be evaluated with \code{\link{format_datetime}}, which means that a format like \code{"d-mmm-yy"} with be translated internally to \code{"\%e-\%b-\%y"} for convenience. See Examples.}
  \item{\code{clean_numeric} and \code{clean_character()}:\cr}{Use parameter \code{keep} to match values that must be kept, using case-insensitive regular expressions (\link[base]{regex}). See Examples.}
}

The use of invalid regular expressions in any of the above functions will not return an error (like in base R), but will instread interpret the expression as a fixed value and will throw a warning.
}
\examples{
# LOGICALS
clean_logical(c("Yes", "No"))
clean_logical(x = c("Positive", "Negative", "Unknown", "Some value"),
              true = "pos", false = "neg")

# FACTORS
gender_age <- c("male 0-50", "male 50+", "female 0-50", "female 50+")
clean_factor(gender_age, c("M", "F"))
clean_factor(gender_age, c("Male", "Female"))
clean_factor(gender_age, c("0-50", "50+"), ordered = TRUE)

# DATES
clean_Date("13jul18", "ddmmmyy")
clean_Date("12 august 2010")
clean_Date("12 06 2012")
# got sent data from Excel?
clean_Date(36526)
clean_Date("43658")
clean_Date("14526", "Excel") # "1939-10-08"

# NUMERICS
clean_numeric("qwerty123456")
clean_numeric("Positive (0.143)")

# CHARACTERS
clean_character("qwerty123456")
clean_character("Positive (0.143)")
 
# GUESS TYPE OF CLASS
clean("12 06 2012")
clean(data.frame(dates = "2013-04-02", 
                 logicals = c("yes", "no")))

\donttest{                  
# Clean data?
freq(unclean$gender)

# Clean it and check again:
freq(clean_factor(unclean$gender, 
                  levels = c("^m" = "Male", "^f" = "Female")))
}
}
